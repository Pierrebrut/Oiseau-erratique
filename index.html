<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>La Machine Qui Respire</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="life"></canvas>
    <script>
        const canvas = document.getElementById("life");
        const ctx = canvas.getContext("2d");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const resolution = 10;
        const cols = Math.floor(canvas.width / resolution);
        const rows = Math.floor(canvas.height / resolution);
        let grid = buildGrid();
        let rules = [2, 3]; // Règles d'évolution (vivre ou naître)

        function buildGrid() {
            return new Array(cols).fill(null).map(() => new Array(rows).fill(0));
        }

        function seedGrid() {
            for (let col = 0; col < cols; col++) {
                for (let row = 0; row < rows; row++) {
                    grid[col][row] = Math.random() > 0.9 ? 1 : 0;
                }
            }
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let col = 0; col < cols; col++) {
                for (let row = 0; row < rows; row++) {
                    const cell = grid[col][row];
                    ctx.beginPath();
                    ctx.rect(col * resolution, row * resolution, resolution, resolution);
                    ctx.fillStyle = cell ? `rgba(255, 182, 193, 0.7)` : "#000";
                    ctx.fill();
                }
            }
        }

        function countNeighbors(grid, x, y) {
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            return neighbors.reduce((count, [dx, dy]) => {
                const col = x + dx;
                const row = y + dy;
                return count + (grid[col]?.[row] || 0);
            }, 0);
        }

        function nextGeneration() {
            const nextGrid = buildGrid();
            for (let col = 0; col < cols; col++) {
                for (let row = 0; row < rows; row++) {
                    const cell = grid[col][row];
                    const neighbors = countNeighbors(grid, col, row);

                    if (cell && (neighbors < rules[0] || neighbors > rules[1])) {
                        nextGrid[col][row] = 0; // Mort
                    } else if (!cell && neighbors === rules[1]) {
                        nextGrid[col][row] = 1; // Naissance
                    } else {
                        nextGrid[col][row] = cell; // Stase
                    }
                }
            }
            grid = nextGrid;
        }

        function mutateRules() {
            // Les règles évoluent légèrement au fil du temps
            if (Math.random() > 0.99) {
                rules[0] = Math.floor(Math.random() * 4) + 1; // 1 à 4
                rules[1] = Math.floor(Math.random() * 5) + 2; // 2 à 6
            }
        }

        canvas.addEventListener("click", (e) => {
            const col = Math.floor(e.clientX / resolution);
            const row = Math.floor(e.clientY / resolution);
            grid[col][row] = 1; // Naissance d'une cellule au clic
        });

        function update() {
            mutateRules();
            nextGeneration();
            drawGrid();
            requestAnimationFrame(update);
        }

        seedGrid();
        update();
    </script>
</body>
</html>
