<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Créature Visqueuse en 3D</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2em;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info">Cliquez pour ajouter de l'énergie.</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialisation de la scène 3D
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lumières
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Taille de la grille et des cubes
        const size = 20; // Dimensions de la grille (20x20x20)
        const cubeSize = 0.2; // Taille d'un cube

        // Grille 3D
        const grid = new Array(size)
            .fill(null)
            .map(() => new Array(size).fill(null).map(() => new Array(size).fill(0)));

        const cubes = []; // Stocker les cubes actifs
        const material = new THREE.MeshStandardMaterial({ color: 0xffb6c1 });

        // Créer un cube dans la grille
        function createCube(x, y, z) {
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(
                (x - size / 2) * cubeSize,
                (y - size / 2) * cubeSize,
                (z - size / 2) * cubeSize
            );
            scene.add(cube);
            cubes.push({ cube, x, y, z });
        }

        // Initialiser la créature
        function initializeCreature() {
            for (let x = 8; x < 12; x++) {
                for (let y = 8; y < 12; y++) {
                    for (let z = 8; z < 12; z++) {
                        if (Math.random() > 0.8) {
                            grid[x][y][z] = 1;
                            createCube(x, y, z);
                        }
                    }
                }
            }
        }

        // Compter les voisins actifs
        function countNeighbors(x, y, z) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        const nz = z + dz;
                        if (nx >= 0 && ny >= 0 && nz >= 0 && nx < size && ny < size && nz < size) {
                            count += grid[nx][ny][nz];
                        }
                    }
                }
            }
            return count;
        }

        // Appliquer les règles de la vie
        function updateCreature() {
            const newGrid = JSON.parse(JSON.stringify(grid)); // Copie de la grille actuelle

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        const neighbors = countNeighbors(x, y, z);

                        if (grid[x][y][z] === 1) {
                            // Une cellule vivante survit si elle a 2 ou 3 voisins
                            if (neighbors < 2 || neighbors > 3) newGrid[x][y][z] = 0;
                        } else {
                            // Une cellule morte devient vivante si elle a exactement 3 voisins
                            if (neighbors === 3) newGrid[x][y][z] = 1;
                        }
                    }
                }
            }

            // Mettre à jour les cubes
            for (let i = cubes.length - 1; i >= 0; i--) {
                const { cube, x, y, z } = cubes[i];
                if (newGrid[x][y][z] === 0) {
                    scene.remove(cube);
                    cubes.splice(i, 1);
                }
            }

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        if (newGrid[x][y][z] === 1 && grid[x][y][z] === 0) {
                            createCube(x, y, z);
                        }
                    }
                }
            }

            grid.forEach((layer, x) =>
                layer.forEach((row, y) => row.forEach((cell, z) => (grid[x][y][z] = newGrid[x][y][z])))
            );
        }

        // Animation et mise à jour
        function animate() {
            updateCreature();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Interaction
        window.addEventListener("click", () => {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const z = Math.floor(Math.random() * size);
            grid[x][y][z] = 1; // Ajouter une cellule vivante
        });

        initializeCreature();
        animate();
    </script>
</body>
</html>
